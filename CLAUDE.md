# Simple Timer プロジェクト

## プロジェクト概要
MacのデスクトップElectronアプリとして、AS Timerユーザーが乗り換えたくなるレベルのタイマーアプリを開発する。

## 目的
- 普段使いのタイマー（集中作業・生活リズム・リマインドなどに）

## 対象ユーザー
- 自分（Macユーザー）
- AS Timerユーザーが「乗り換えたくなる」レベルを目指す

## 必須機能（MVP）
- カウントダウンタイマー（分単位）
- スタート・ストップ・リセット
- シンプルなUI（なるべくマウス不要で完結）
- 通知（終了時の音やポップアップ）

## 追加したい機能（Nice to have）
- キーボードショートカット
- ダークモード対応
- メニューバー常駐
- 設定プリセット（25分集中/5分休憩 みたいな）
- 作業ログ（何回タイマー回したか）

## 技術スタック
- Platform: Mac デスクトップ
- Framework: Electron
- Language: JavaScript/TypeScript（未定）

## 開発順序
1. **基本セットアップ**
   - Electron環境構築
   - 基本的なウィンドウ表示

2. **コアタイマー機能**
   - カウントダウンロジック
   - 分単位の時間設定
   - スタート/ストップ/リセット

3. **シンプルUI**
   - 最小限のボタンとディスプレイ
   - キーボードショートカット（Space:開始/停止、R:リセット、数字:時間設定）

4. **通知機能**
   - タイマー終了時の音
   - Mac通知センター連携

5. **追加機能（優先度順）**
   - ダークモード
   - メニューバー常駐
   - プリセット（25分/5分など）
   - 作業ログ

## 開発進捗

### Phase 1: 基本実装 ✅
- [x] Electronプロジェクトの初期セットアップ
- [x] 基本的なタイマー機能の実装（カウントダウン、スタート・ストップ・リセット）
- [x] 円形プログレスバーによる視覚的UI
- [x] アイコンベースの操作ボタン（再生・リセット）

### Phase 2: UI最適化 ✅
- [x] レイアウト調整とボタン配置の最適化
- [x] アプリサイズの最適化（180x180正方形ウィンドウ）
- [x] プログレスリング周辺へのボタン配置

### Phase 3: アプリ配布対応 ✅
- [x] electron-builderによるmacOSアプリパッケージング
- [x] Intel/Apple Silicon両対応のDMG生成
- [x] カスタムアプリアイコンの作成と実装
- [x] 透明角処理によるアイコン品質向上

### 今後のタスク
- [ ] 通知機能の実装（音・Mac通知）
- [ ] キーボードショートカットの実装
- [ ] ダークモード対応
- [ ] メニューバー常駐機能
- [ ] プリセット機能（ポモドーロなど）
- [ ] 作業ログ機能

## 技術仕様

### アーキテクチャ
- **メインプロセス**: `src/main.ts` - Electronウィンドウ管理
- **レンダラー**: `src/renderer.ts` - タイマーロジックとUI制御
- **スタイリング**: `style.css` - フレックスボックスレイアウト

### ウィンドウ設定
- サイズ: 180x180px（正方形）
- リサイズ不可
- 常に最前面表示

### UI要素
- **進捗表示**: SVGによる円形プログレスリング（半径65px）
- **操作ボタン**: アイコンベース（再生/一時停止、リセット）
- **配置**: タイマー円周辺の右上・左下エリア

### ビルド設定
- **ターゲット**: macOS (Intel/Apple Silicon)
- **出力形式**: DMG、ZIP
- **アイコン**: 透明角処理済みicnsファイル

## リポジトリ
https://github.com/little-hands/simple-timer

## 関連ドキュメント
- [UI要素名一覧](UI_ELEMENTS.md) - 指示時に使用する各要素の名称定義

## 作業用ドキュメント管理ルール

### work_documents/ ディレクトリ
一時的な作業ファイルやメモは `work_documents/` ディレクトリ内で管理する。

#### 基本ルール
- **Git管理対象外**: `.gitignore` で除外されており、コミットされない
- **一時的なファイル専用**: 実装プラン、TODO、作業メモなどの一時的なファイルのみ
- **作業完了後の移動**: 必要な情報は `CLAUDE.md`、コード内コメント、Issue等の適切な場所に移動

#### ファイル命名規則
```
issue-{イシュー番号}_{作業内容の概要}.md
```

**命名例:**
- `issue-1_direct-number-input-implementation.md` - Issue #1: 直接数字入力機能実装
- `issue-3_menubar-resident-feature.md` - Issue #3: メニューバー常駐機能実装
- `issue-6_dark-mode-support.md` - Issue #6: ダークモード対応

#### 使用用途
- **実装計画**: 段階的開発のフェーズ設計
- **進捗管理**: チェックリスト形式の作業進捗
- **作業メモ**: 実装中の注意点や発見事項
- **ユーザー確認手順**: 動作確認の具体的な手順書
- **トラブルシューティング**: 問題発生時の対処法

#### ベストプラクティス
- **Issue番号の明記**: 対応するGitHub Issue番号を必ず含める
- **作業概要の明記**: ファイル名から内容が推測できるようにする
- **完了後のクリーンアップ**: 作業完了時に必要な情報を適切な場所に移動
- **バックアップ不要**: 一時ファイルのため、削除しても問題ない前提で管理

## GitHub Issue テンプレート

新機能や改善要求のissueを作成する際は、以下のテンプレート構造に従うこと：

### 1. ユーザーストーリー
```
[ユーザータイプ]として、
[機能・要求]がしたい。
なぜなら[理由・背景]
```

### 2. 受入基準
Gherkin記法（Given-When-Then）を使用してテストシナリオを記述：
```
**Scenario 1: [シナリオ名]**
- Given [前提条件]
- When [アクション]
- Then [期待される結果]

**Scenario 2: [シナリオ名]**
- Given [前提条件]  
- When [アクション]
- Then [期待される結果]
```

### 3. 技術設計
以下の項目を含む技術設計の詳細：
- **現在の実装状況分析**
- **アーキテクチャ選択の根拠**
- **実装アプローチ**
- **具体的なコード修正内容**（ファイル別）
- **設計改善ポイント**
- **エラーハンドリング戦略**
- **テスト手法の推奨事項**

このテンプレートにより、ユーザー視点から技術実装まで包括的にカバーし、実装の品質と一貫性を確保する。

## 開発フロー - Electron自動起動システム


## tmux操作ガイド

### tmux send-keysコマンドの使用ルール
**文字列を送信する場合は**、必ず以下の形式で実行すること：
```bash
tmux send-keys -t {ペインID（%N形式）} "{送信する文字列}" && sleep 0.2 Enter
```

## 開発ベストプラクティス

### 段階的開発手法

#### 1. Issue管理のベストプラクティス
- **粒度の細分化**: 大きな機能を小さな実装可能な単位に分解
- **ラベリング**: カテゴリ別ラベル（例：通知機能🔔、メニューバー常駐📍）で分類
- **ユーザーストーリー**: Gherkin記法（Given-When-Then）で受入基準を明確化
- **技術設計**: アーキテクチャ選択の根拠と具体的実装手順を文書化

#### 2. 段階的開発プロセス
新機能開発時は以下の段階を踏む：

**Phase 1: 現状確認**
- 既存機能の動作確認
- 基盤となるコードの理解
- 既存実装との競合チェック

**Phase 2-N: 段階的実装**
- 各段階で1つの明確な目標設定
- 段階ごとの動作確認（自動 + ユーザー確認）
- 問題発生時の切り戻し可能性確保

**最終段階: 統合テスト**
- エンドツーエンドでの動作確認
- 既存機能への影響確認
- ユーザー受入テスト

#### 3. セッション継続性の確保
- **TODO管理ファイル**: セッション間で進捗を引き継ぐためのMarkdownファイル作成
- **チェックリスト形式**: 各段階の作業内容と確認項目を明示
- **ユーザー確認ポイント**: 自動化できない部分の明確な指示
- **トラブルシューティング**: よくある問題と解決方法の事前記載

#### 4. 品質確保のポイント

**各段階での必須確認項目**
- [ ] `npm run build` でエラーがない
- [ ] TypeScriptコンパイルエラーがない
- [ ] 既存機能が正常動作する
- [ ] コンソールエラーがない（DevTools + ターミナル）

**ユーザー確認が必要なタイミング**
- UI/UXに関わる変更の確認
- 通知やサウンドなどのOS連携機能
- ウィンドウ動作やフォーカス変更
- エンドツーエンドの動作確認

**ユーザー確認の具体的な指示方法**
- **手順の明確化**: 「1分タイマーを設定→開始→待機→確認」のような具体的ステップ
- **期待動作の詳細**: 「画面右上にブラウザ風の四角いポップアップが表示される」など、見た目や動作を具体的に記述
- **確認項目のチェックリスト**: 各要素を個別にチェックできるリスト形式
- **問題時の対処法**: 「通知が表示されない場合：ブラウザの通知許可設定を確認」のような具体的な対処方法
- **比較確認**: 「Phase 4の時と比べて通知が1つ減った」のような前後比較
- **ビフォーアフターの明示**: 「従来は◯◯だったが、新しくは××になる」の形式で変化を明確化

#### 5. 技術債務の管理
- **設計見直し**: 実装前のアーキテクチャ検討と改善提案
- **段階的リファクタリング**: 既存コードとの統合を考慮した設計
- **型安全性**: TypeScriptの型定義を活用した堅牢な実装
- **責任分離**: メインプロセスとレンダラープロセスの適切な役割分担

#### 6. 開発効率化
- **並行開発の回避**: 一度に一つの機能に集中
- **最小単位での動作確認**: 問題の早期発見と修正
- **既存機能の保護**: 新機能追加時の既存機能への影響最小化
- **ドキュメント駆動**: 実装前の設計文書化と合意形成

### 適用例
Mac通知センター連携機能の開発では：
1. 11個の細かいIssueに分解
2. 6段階の実装フェーズ設計
3. 各段階でのユーザー確認ポイント明示
4. セッション継続用のTODOファイル作成
5. 既存HTML5通知からネイティブ通知への段階的移行

この手法により、大きな機能でも安全かつ確実に実装が可能。